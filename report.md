# 增量型安全文件系统 SFS

## 引言

文件系统是计算机系统中为用户提供数据存储服务的一个很好的选择。然而，根据我们有限的调研，大部分通用文件系统在设计上没有特别考虑文件的永久性存储。这里的永久性指的是，文件及其每一个版本都在底层存储介质上永久保存。因此，“删库跑路”等事故时有发生。例如，一个对高层不满的系统管理员可能会通过运行`rm -rf /`命令来删除系统中的所有文件，从而表达他的不满。由于被上述命令删除的文件不难恢复，所以，稍有经验的系统管理员可能还会向文件系统写入垃圾数据来覆盖实际上未被清除的数据。此外，菜鸟系统管理员亦可能受到他人的教唆而运行这样的命令，为企业带来损失。可见，一个能够对文件永久性存储的文件系统是必要的。

为此，考虑到git [Git. 2018]是一个能够跟踪每一个文件版本的版本控制系统，我们在git的基础上提出了一种新型的增量型安全文件系统。

本文分为这样几个部分：“相关工作”介绍了前人的已有工作，“设计与实现”介绍了我们的设计与实现思路，“实验”部分给出了对于我们的方法的性能测试以及讨论。最后，“结论”一节对全文进行了总结。

## 相关工作

Git [Git. 2018]是一个能够跟踪每一个文件版本的版本控制系统。gitfs [presslabs. 2018]也是一个基于git的文件系统，不过其核心功能在于让用户能够很方便地以文件系统的方式来访问git仓库及其各个版本和分支。微软公司提出的GVFS [Microsoft. 2018]同样是基于git的文件系统，他们的关注点则在于访问大仓库时的性能，以及减少网络传输的数据量。

## 设计与实现

整体系统使用用户态文件系统libfuse实现。

一个使用Git管理的项目，可分为工作区、缓冲区和版本库三个部分。工作区即项目目录中直接可见的文件，缓冲区即调用`git add`后暂存的文件，版本库即`.git`目录中的信息。要使用Git实现文件系统，最简单的方式是：将各项文件操作直接转发为对于工作区的文件操作，只有需要保存增量副本时，才commit到版本库。然而，这样实际上将每个文件在工作区和版本库中各存了一份副本，空间开销很大。为了优化空间开销，我们使用了libgit2库以直接解析版本库。对于大多数操作，例如列出目录内容、获取文件属性等，可以直接在版本库中操作，而不必提取具体的文件到工作区。只有当打开（`open`）一个文件时，为了避免直接对版本库进行操作带来的额外开销，我们将被打开文件的内容缓存到临时文件中，读（`read`）、写（`write`）、改变文件长度（`truncate`）操作就直接对该临时文件进行，而在关闭（`release`）时删除该临时文件，并在版本库中直接构造一个commit，包含该文件的具体变更内容。

除了在关闭文件时保存增量副本（commit）以外，根据安全性的不同，版本控制的策略也可以有不同的选择。对于文件，我们的设计目前支持三种版本控制策略：

1. `commit-on-close`：文件每次被关闭时，将缓冲区中的文件数据提交到git仓库；
2. `timed-commit`：可设定一个时间阈值，每超过此阈值再进行写入时，将缓冲区中的文件数据提交到git仓库；
3. `commit-on-write`：文件每次被写入后，将缓冲区中的文件数据提交到git仓库；

以上三种策略，安全性和时间空间开销均依次增大。一般而论，`commit-on-close`已经可以提供足够的安全性；对于安全性要求较高的场合，可以尝试`timed-commit`；`commit-on-write`安全性最高，但由于开销过大，只具有理论意义。

对于其他写操作，我们把每一次操作都提交到git仓库。

此外，我们还提供了一些人性化功能，例如：

- 在挂载时可以指定SFS回滚到某个指定时间之前的最新一个版本，SFS会在此版本基础上新建一个分支继续存储，而不丢失原来的数据；
- SFS可以以只读模式挂载；

## 测试

### 实验环境

* `libfuse`：版本2.9.4，使用`apt install libfuse-dev`安装；
* `libgit2`：版本0.24.1，使用`apt install libgit2-dev`安装；
* `fio`：版本2.2.10，使用`apt install fio`安装；
* 其他必要的GCC工具链。

### 正确性测试

在分别实现并测试SFS的各个接口之后，我们使用在SFS上编译运行一个真实项目的方式，来测试SFS综合运行各个功能的正确性，以及处理并发请求的正确性。我们选用μCore这个小型操作系统作为测试样本，使用`make -j8`并行编译，编译后μCore可以正常运行。

为了进一步测试SFS并发读写的正确性，我们使用FIO测试工具，并发地读写4个文件，每个文件使用8个线程进行随机并发读写，利用CRC32校验和检查正确性。SFS可以通过测试。

### 性能测试

我们使用FIO进一步进行了性能测试。测试环境如下：

- 硬盘（HDD）：Hitachi HTS547564A9E384(JEDOA50A)；
- 运行基准测试和运行于SFS之下的文件系统：EXT4；
- 使用OS文件缓存（buffered mode），这是因为SFS内部使用了临时文件，FIO无法做到关闭这些临时文件的缓存；
- 写测试中，所有数据写入完毕后，调用`fsync`强制写回硬盘。

实验结果：

**顺序写入64MB实验：**



## 结论

但我们的方法也有缺点：

- 我们的文件系统对于底层存储设备空间的占用只增不减，在某些情况下这可能成为经济压力；
- 由于在Git中获取某文件的修改时间需要扫描分支树，开销过大，故没有记录文件的修改时间；
- 只能提供0644和0755两种访问权限。

## 参考文献

* Git. 2018. *git*. https://git-scm.com/
* presslabs. 2018. *gitfs*. https://github.com/presslabs/gitfs
* Microsoft. 2018. *GVFS*. https://github.com/Microsoft/GVFS
