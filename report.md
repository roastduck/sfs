# 增量型安全文件系统 SFS

## 引言

文件系统是计算机系统中为用户提供数据存储服务的一个很好的选择。然而，根据我们有限的调研，大部分通用文件系统在设计上没有特别考虑文件的永久性存储。这里的永久性指的是，文件及其每一个版本都在底层存储介质上永久保存。因此，“删库跑路”等事故时有发生。例如，一个对高层不满的系统管理员可能会通过运行`rm -rf /`命令来删除系统中的所有文件，从而表达他的不满。由于被上述命令删除的文件不难恢复，所以，稍有经验的系统管理员可能还会向文件系统写入垃圾数据来覆盖实际上未被清除的数据。此外，菜鸟系统管理员亦可能受到他人的教唆而运行这样的命令，为企业带来损失。可见，一个能够对文件永久性存储的文件系统是必要的。

为此，考虑到git [Git. 2018]是一个能够跟踪每一个文件版本的版本控制系统，我们在git的基础上提出了一种新型的增量型安全文件系统。

本文分为这样几个部分：“相关工作”介绍了前人的已有工作，“设计与实现”介绍了我们的设计与实现思路，“实验”部分给出了对于我们的方法的性能测试以及讨论。最后，“结论”一节对全文进行了总结。

## 相关工作

Git [Git. 2018]是一个能够跟踪每一个文件版本的版本控制系统。gitfs [presslabs. 2018]也是一个基于git的文件系统，不过其核心功能在于让用户能够很方便地以文件系统的方式来访问git仓库及其各个版本和分支。微软公司提出的GVFS [Microsoft. 2018]同样是基于git的文件系统，他们的关注点则在于访问大仓库时的性能，以及减少网络传输的数据量。

## 设计与实现

整体系统使用用户态文件系统libfuse实现。

根据安全性的不同，版本控制的策略也可以有不同的选择。对于文件，我们的设计目前支持三种版本控制策略：

1. `commit-on-close`：文件每次被关闭时，将缓冲区中的文件数据提交到git仓库；
2. `timed-commit`：可设定一个时间阈值，每超过此阈值再进行写入时，将缓冲区中的文件数据提交到git仓库；
3. `commit-on-write`：文件每次被写入后，将缓冲区中的文件数据提交到git仓库；

以上三种策略，安全性和时间空间开销均依次增大。一般而论，`commit-on-close`已经可以提供足够的安全性；对于安全性要求较高的场合，可以尝试`timed-commit`；`commit-on-write`安全性最高，但由于开销过大，只具有理论意义。

对于其他写操作，我们把每一次操作都提交到git仓库。

此外，我们还提供了一些人性化功能，例如：

- 在挂载时可以指定SFS回滚到某个指定时间之前的最新一个版本，SFS会在此版本基础上新建一个分支继续存储，而不丢失原来的数据；
- SFS可以以只读模式挂载；

## 测试

### 实验环境

* `libfuse`：版本2.9.4，使用`apt install libfuse-dev`安装；
* `libgit2`：版本0.24.1，使用`apt install libgit2-dev`安装；
* `fio`：版本2.2.10，使用`apt install fio`安装；
* 其他必要的GCC工具链。

### 正确性测试

在分别实现并测试SFS的各个接口之后，我们使用在SFS上编译运行一个真实项目的方式，来测试SFS综合运行各个功能的正确性，以及处理并发请求的正确性。我们选用μCore这个小型操作系统作为测试样本，使用`make -j8`并行编译，编译后μCore可以正常运行。

为了进一步测试SFS并发读写的正确性，我们使用FIO测试工具，并发地读写4个文件，每个文件使用8个线程进行随机并发读写，利用CRC32校验和检查正确性。SFS可以通过测试。

### 性能测试



## 结论

但我们的方法也有缺点：

- 我们的文件系统对于底层存储设备空间的占用只增不减，在某些情况下这可能成为经济压力；
- 由于在Git中获取某文件的修改时间需要扫描分支树，开销过大，故没有记录文件的修改时间；
- 只能提供0644和0755两种访问权限。

## 参考文献

* Git. 2018. *git*. https://git-scm.com/
* presslabs. 2018. *gitfs*. https://github.com/presslabs/gitfs
* Microsoft. 2018. *GVFS*. https://github.com/Microsoft/GVFS
